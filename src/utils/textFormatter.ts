import type { ChatMessage } from '../types/messages'

/**
 * チャットデータの配列を1つのMarkdown文字列に整形する関数
 * @param chatData - Content Scriptから受け取ったチャットメッセージの配列
 * @returns 整形されたMarkdown文字列
 */
export function formatAsMarkdown(chatData: ChatMessage[]): string {
  if (!chatData || chatData.length === 0) {
    return '# Gemini Chat Export\n\nNo chat messages found.'
  }

  const header = `# Gemini Chat Export

**Generated on:** ${new Date().toLocaleString()}  
**Total messages:** ${chatData.length}

---

`

  const messagesText = chatData
    .map((message, index) => {
      const timestamp = message.timestamp 
        ? new Date(message.timestamp).toLocaleString()
        : 'Unknown time'
      
      const sender = message.type === 'user' ? '👤 User' : '🤖 Gemini'
      let content = message.content.trim()
      
      // Apply Markdown cleanup rules
      content = cleanupMarkdownContent(content)
      
      return `## [${index + 1}] ${sender}

**Time:** ${timestamp}

${content}

`
    })
    .join('\n')

  const footer = `---

*Generated by Gemini Chat Exporter*`

  return header + messagesText + footer
}

/**
 * Markdownコンテンツのクリーンアップを行う関数
 * @param content - クリーンアップするMarkdown文字列
 * @returns クリーンアップされたMarkdown文字列
 */
function cleanupMarkdownContent(content: string): string {
  let result = content;
  
  // Step 1: コードブロック内の無駄な改行を確実に除去
  // より包括的なパターンマッチングで、あらゆる空白・改行パターンに対応
  
  // 1-1: 言語指定なしのコードブロック（最も問題の多いパターン）
  // ```の直後に改行・空白が続き、その後にコンテンツ、最後に```で終わるパターン
  result = result.replace(/```\s*\n[\s\n]*([^`]+?)[\s\n]*```/gs, (_, code) => {
    const cleanCode = code.trim();
    return cleanCode ? `\`\`\`\n${cleanCode}\n\`\`\`` : '';
  });
  
  // 1-2: 言語指定ありのコードブロック
  // ```言語名の直後に改行・空白が続くパターン
  result = result.replace(/```(\w+)\s*\n[\s\n]*([^`]+?)[\s\n]*```/gs, (_, lang, code) => {
    const cleanCode = code.trim();
    return cleanCode ? `\`\`\`${lang}\n${cleanCode}\n\`\`\`` : '';
  });
  
  // 1-3: 空の言語指定（```の直後にスペースがある場合）
  // ```␣の直後に改行・空白が続くパターン
  result = result.replace(/```\s+\n[\s\n]*([^`]+?)[\s\n]*```/gs, (_, code) => {
    const cleanCode = code.trim();
    return cleanCode ? `\`\`\`\n${cleanCode}\n\`\`\`` : '';
  });
  
  // Step 2: 残存する問題パターンへの対応
  
  // 2-1: 連続する空白行パターンへの追加処理
  result = result.replace(/```(\w*)\n\s*\n+([^`]+?)\n\s*```/gs, (_, lang, code) => {
    const cleanCode = code.trim();
    return cleanCode ? `\`\`\`${lang}\n${cleanCode}\n\`\`\`` : '';
  });
  
  // 2-2: コードブロック内の連続する空白行を単一の改行に変換
  result = result.replace(/```(\w*)\n([^`]*?)\n```/gs, (_, lang, code) => {
    // コード内の連続する空白行を正規化（ただし意図的な改行は保持）
    const normalizedCode = code
      .replace(/\n\s*\n\s*\n/g, '\n\n')  // 3つ以上の連続改行を2つに
      .replace(/^\s+|\s+$/g, '');  // 前後の空白を除去
    
    return normalizedCode ? `\`\`\`${lang}\n${normalizedCode}\n\`\`\`` : '';
  });
  
  // Step 3: コードブロック周辺の改行調整
  
  // 3-1: コードブロック前の過度な改行
  result = result.replace(/\n{3,}```/g, '\n\n```');
  
  // 3-2: コードブロック後の過度な改行
  result = result.replace(/```\n{3,}/g, '```\n\n');
  
  // Step 4: その他の一般的なクリーンアップ
  
  // 4-1: インラインコード後の不要な空白を除去
  result = result.replace(/`([^`]+)`\s{2,}/g, '`$1` ');
  
  // 4-2: 複数の改行を2つまでに制限
  result = result.replace(/\n{3,}/g, '\n\n');
  
  // 4-3: リスト項目の改行を正規化
  result = result.replace(/^(\s*[-*+]\s+.+)\n+(?=\s*[-*+])/gm, '$1\n');
  result = result.replace(/^(\s*\d+\.\s+.+)\n+(?=\s*\d+\.)/gm, '$1\n');
  
  // 4-4: 文末・文頭の不要な空白行を除去
  result = result.replace(/\n+$/, '').replace(/^\n+/, '');
  
  // 4-5: コードブロック直後にテキストが続く場合の改行調整
  result = result.replace(/```\n([^\s\n`])/g, '```\n\n$1');
  
  return result;
}

/**
 * 従来のテキスト形式との互換性のために残しておく関数
 * @param chatData - Content Scriptから受け取ったチャットメッセージの配列
 * @returns 整形されたプレーンテキスト文字列
 */
export function formatAsText(chatData: ChatMessage[]): string {
  // Markdownとして出力（後方互換性のため）
  return formatAsMarkdown(chatData)
}

/**
 * Markdownファイル名を生成する関数
 * @param prefix - ファイル名のプレフィックス (デフォルト: 'gemini-chat')
 * @returns タイムスタンプ付きのMarkdownファイル名
 */
export function generateFileName(prefix: string = 'gemini-chat'): string {
  const now = new Date()
  const dateStr = now.toISOString().split('T')[0] // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-') // HH-MM-SS
  
  return `${prefix}_${dateStr}_${timeStr}.md`
} 
